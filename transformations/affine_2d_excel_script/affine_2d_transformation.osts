{"version":"0.3.0","body":"// Author: Farid Javadnejad\n// Institution: WSP Geomatics USA, Inc.\n// Date: 2025-06-26\n// \n// DESCRIPTION:\n// This Office Script computes a 2D affine transformation using point coordinates stored in Excel.\n// It reads coordinate pairs from two worksheets: \"SOURCE\" and \"TARGET\", each containing corresponding X and Y values.\n// The script calculates the affine transformation coefficients and residuals, and writes the results to a \"REPORT\"\n//\n// USAGE:\n// - Ensure the \"SOURCE\" and \"TARGET\" sheets each contain at least 3 matching point pairs.\n// - Column B contains Y (Northing) and column C contains X (Easting) values, with one header row.\n// - Run the script to generate or update a \"REPORT\" sheet with the calculated affine coefficients and residual statistics.\n//\n// EXAMPLE:\n// SOURCE:\n// PID    Northing (Y)    Easting (X)\n// 1      488591.5266     644005.776\n// 2      489757.2155     650091.4286\n// 3      490392.2533     657073.5145\n//\n// TARGET:\n// PID    Northing (Y)    Easting (X)\n// 1      488507.6308     643999.1308\n// 2      489696.2621     650080.3439\n// 3      490357.6270     657059.9853\n// \n// REPORT:\n// Affine Transformation Coefficients\t\n// A0\t1840.558024338450\n// A1 -0.003771297073\n// A2\t0.999992889100\n// B0 -2509.155695965060\n// B1\t0.999992882650\n// B2\t0.003771297443\n//\n// DISCLAIMER:\n// This script was developed with the assistance of AI tools for coding, debugging, and validation.\n// -----------------------------------------------------------------------------------------------\n\nfunction main(workbook: ExcelScript.Workbook) {\n  const sourceSheet = workbook.getWorksheet(\"SOURCE\");\n  const targetSheet = workbook.getWorksheet(\"TARGET\");\n  let reportSheet = workbook.getWorksheet(\"REPORT\");\n\n  if (!reportSheet) {\n    reportSheet = workbook.addWorksheet(\"REPORT\");\n  } else {\n    reportSheet.getUsedRange()?.clear();\n  }\n\n  const sourceData = sourceSheet.getUsedRange()?.getValues() || [];\n  const targetData = targetSheet.getUsedRange()?.getValues() || [];\n\n  // Skip headers (start from row 2)\n  const srcCoords = sourceData.slice(1).filter(row => row[1] !== \"\" && row[2] !== \"\");\n  const tgtCoords = targetData.slice(1).filter(row => row[1] !== \"\" && row[2] !== \"\");\n\n  if (srcCoords.length !== tgtCoords.length) {\n    throw new Error(`Mismatch: SOURCE has ${srcCoords.length} valid points, TARGET has ${tgtCoords.length}.`);\n  }\n\n  const n = srcCoords.length;\n\n  if (n < 3) {\n    throw new Error(\"At least 3 valid point pairs are required for affine transformation.\");\n  }\n\n  const A: number[][] = [];\n  const bx: number[] = [];\n  const by: number[] = [];\n\n  for (let i = 0; i < n; i++) {\n    const Y = Number(srcCoords[i][1]);\n    const X = Number(srcCoords[i][2]);\n    A.push([1, Y, X]);\n    bx.push(Number(tgtCoords[i][2]));\n    by.push(Number(tgtCoords[i][1]));\n  }\n\n  const At = transpose(A);\n  const AtA = multiply(At, A);\n  const Atbx = multiply(At, bx);\n  const Atby = multiply(At, by);\n\n  const coeffsX = solve3x3(AtA, Atbx); // A0, A1, A2\n  const coeffsY = solve3x3(AtA, Atby); // B0, B1, B2\n\n  const coeffLabels = [\"A0\", \"A1\", \"A2\", \"B0\", \"B1\", \"B2\"];\n  const coeffValues = [...coeffsX, ...coeffsY];\n  const coeffOutput = coeffLabels.map((label, i) => [label, coeffValues[i]]);\n\n  reportSheet.getRange(\"A1\").setValue(\"Affine Transformation Coefficients\");\n  reportSheet.getRange(\"A2:B7\").setValues(coeffOutput);\n\n  const residualStartRow = 9;\n  reportSheet.getRange(`A${residualStartRow}`).setValue(\"Residuals\");\n  reportSheet.getRange(`A${residualStartRow + 1}:C${residualStartRow + 1}`).setValues([[\"Point #\", \"dX\", \"dY\"]]);\n\n  let residualRows: (string | number)[][] = [];\n  let dxVals: number[] = [];\n  let dyVals: number[] = [];\n\n  for (let i = 0; i < n; i++) {\n    const Y = Number(srcCoords[i][1]);\n    const X = Number(srcCoords[i][2]);\n\n    const estX = coeffsX[0] + coeffsX[1] * Y + coeffsX[2] * X;\n    const estY = coeffsY[0] + coeffsY[1] * Y + coeffsY[2] * X;\n\n    const dx = estX - Number(tgtCoords[i][2]);\n    const dy = estY - Number(tgtCoords[i][1]);\n\n    dxVals.push(dx);\n    dyVals.push(dy);\n\n    residualRows.push([i + 1, dx, dy]);\n  }\n\n  reportSheet.getRange(`A${residualStartRow + 2}:C${residualStartRow + 1 + residualRows.length}`).setValues(residualRows);\n\n  const maxDx = Math.max(...dxVals.map((x) => Math.abs(x)));\n  const maxDy = Math.max(...dyVals.map((y) => Math.abs(y)));\n\n  const avgDx = dxVals.reduce((sum, x) => sum + Math.abs(x), 0) / n;\n  const avgDy = dyVals.reduce((sum, y) => sum + Math.abs(y), 0) / n;\n\n  const rmsDx = Math.sqrt(dxVals.reduce((sum, x) => sum + x * x, 0) / n);\n  const rmsDy = Math.sqrt(dyVals.reduce((sum, y) => sum + y * y, 0) / n);\n\n  const summaryStartRow = residualStartRow + 3 + residualRows.length;\n  reportSheet.getRange(`A${summaryStartRow}:C${summaryStartRow + 2}`).setValues([\n    [\"Max\", maxDx, maxDy],\n    [\"Avg\", avgDx, avgDy],\n    [\"RMS\", rmsDx, rmsDy]\n  ]);\n\n  const lastRow = summaryStartRow + 2;\n  const formatRange = reportSheet.getRange(`B2:C${lastRow}`);\n  formatRange.setNumberFormatLocal(\"0.000000000000\");\n\n  // === Helper Functions ===\n  function transpose(m: number[][]): number[][] {\n    return m[0].map((_, i) => m.map((row) => row[i]));\n  }\n\n  function multiply(a: number[][], b: number[][] | number[]): number[][] | number[] {\n    if (typeof (b as number[])[0] === \"number\") {\n      return a.map((row) =>\n        row.reduce((sum, val, i) => sum + val * (b as number[])[i], 0)\n      );\n    } else {\n      const bMat = b as number[][];\n      return a.map((row) =>\n        bMat[0].map((_, j) =>\n          row.reduce((sum, val, k) => sum + val * bMat[k][j], 0)\n        )\n      );\n    }\n  }\n\n  function solve3x3(A: number[][], b: number[]): number[] {\n    const M = A.map((row, i) => [...row, b[i]]);\n    const n = 3;\n\n    for (let i = 0; i < n; i++) {\n      let maxRow = i;\n      for (let k = i + 1; k < n; k++) {\n        if (Math.abs(M[k][i]) > Math.abs(M[maxRow][i])) maxRow = k;\n      }\n      [M[i], M[maxRow]] = [M[maxRow], M[i]];\n\n      const pivot = M[i][i];\n      for (let j = i; j <= n; j++) {\n        M[i][j] /= pivot;\n      }\n\n      for (let k = 0; k < n; k++) {\n        if (k !== i) {\n          const factor = M[k][i];\n          for (let j = i; j <= n; j++) {\n            M[k][j] -= factor * M[i][j];\n          }\n        }\n      }\n    }\n\n    return M.map((row) => row[n]);\n  }\n}\n","description":"","noCodeMetadata":"","parameterInfo":"{\"version\":1,\"originalParameterOrder\":[],\"parameterSchema\":{\"type\":\"object\",\"default\":{},\"x-ms-visibility\":\"internal\"},\"returnSchema\":{\"type\":\"object\",\"properties\":{}},\"signature\":{\"comment\":\"\",\"parameters\":[{\"name\":\"workbook\",\"comment\":\"\"}]}}","apiInfo":"{\"variant\":\"synchronous\",\"variantVersion\":2}"}
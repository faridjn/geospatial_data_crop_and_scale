{"version":"0.3.0","body":"// Author: Farid Javadnejad\n// Instutiotn: WSP Geomatics USA\n// Date: 2025-06-26\n\n// DESCRIPTION:\n// This Office Script computes a 2D affine transformation from point coordinates stored in Excel.\n// It reads coordinate pairs from two worksheets: \"SOURCE\" and \"TARGET\", each containing matching X and Y values.\n// The script calculates the transformation coefficients and residuals, and writes the results to a \"REPORT\" sheet.\n//\n// USAGE:\n// - Ensure \"SOURCE\" and \"TARGET\" sheets have at least 3 matching point pairs in columns B (Y) and C (X), starting from row 2.\n// - Run this script to create/update a \"REPORT\" sheet with affine coefficients and residual statistics.\n//\n// DISCLAIMER:\n// This script was developed with the assistance of AI tools for coding, debugging, and validation.\n// ----\n\nfunction main(workbook: ExcelScript.Workbook) {\n    const srcSheet = workbook.getWorksheet(\"SOURCE\");\n    const tgtSheet = workbook.getWorksheet(\"TARGET\");\n    let reportSheet = workbook.getWorksheet(\"REPORT\");\n\n    if (!reportSheet) {\n        reportSheet = workbook.addWorksheet(\"REPORT\");\n    } else {\n        reportSheet.getRange().clear();\n    }\n\n    const srcData = srcSheet.getRange(\"B2:C100\").getValues().filter(row => row[0] !== \"\" && row[1] !== \"\");\n    const tgtData = tgtSheet.getRange(\"B2:C100\").getValues().filter(row => row[0] !== \"\" && row[1] !== \"\");\n    const n = Math.min(srcData.length, tgtData.length);\n    if (n < 3) {\n        reportSheet.getRange(\"A1\").setValue(\"Need at least 3 point pairs.\");\n        return;\n    }\n\n    const X: number[][] = [];\n    const Yx: number[] = [];\n    const Yy: number[] = [];\n\n    for (let i = 0; i < n; i++) {\n        const [srcY, srcX] = srcData[i];\n        const [tgtY, tgtX] = tgtData[i];\n\n        X.push([1, srcX as number, srcY as number]);\n        Yx.push(tgtX as number);\n        Yy.push(tgtY as number);\n    }\n\n    const Xt = transpose(X);\n    const XtX = multiply(Xt, X);\n    const XtX_inv = inverse3x3(XtX);\n    const XtYx = multiply(XtX_inv, multiply(Xt, Yx.map(v => [v])));\n    const XtYy = multiply(XtX_inv, multiply(Xt, Yy.map(v => [v])));\n\n    const A = XtYx;\n    const B = XtYy;\n\n    const residuals: number[][] = [];\n    for (let i = 0; i < n; i++) {\n        const [srcY, srcX] = srcData[i];\n        const [tgtY, tgtX] = tgtData[i];\n\n        const Xp = A[0][0] + A[1][0] * (srcX as number) + A[2][0] * (srcY as number);\n        const Yp = B[0][0] + B[1][0] * (srcX as number) + B[2][0] * (srcY as number);\n\n        const dX = (tgtX as number) - Xp;\n        const dY = (tgtY as number) - Yp;\n        residuals.push([dX, dY]);\n    }\n\n    const dXs = residuals.map((r: number[]) => r[0]);\n    const dYs = residuals.map((r: number[]) => r[1]);\n\n    const max = [Math.max(...dXs.map((x: number) => Math.abs(x))), Math.max(...dYs.map((y: number) => Math.abs(y)))];\n    const avg = [average(dXs.map((x: number) => Math.abs(x))), average(dYs.map((y: number) => Math.abs(y)))];\n    const rms = [rmsValue(dXs), rmsValue(dYs)];\n\n    // === Write to REPORT Sheet ===\n    reportSheet.getRange(\"A1\").setValue(\"Affine Transformation Coefficients\");\n    reportSheet.getRange(\"A2:B7\").setValues([\n        [\"A0\", A[0][0]],\n        [\"A1\", A[1][0]],\n        [\"A2\", A[2][0]],\n        [\"B0\", B[0][0]],\n        [\"B1\", B[1][0]],\n        [\"B2\", B[2][0]]\n    ]);\n\n    let startRow = 9;\n    reportSheet.getRange(`A${startRow}`).setValue(\"Residuals (X', Y')\");\n    startRow++;\n    reportSheet.getRange(`A${startRow}:C${startRow}`).setValues([[\"Point #\", \"dX\", \"dY\"]]);\n\n    const resTable = residuals.map((res: number[], i: number) => [i + 1, res[0], res[1]]);\n    reportSheet.getRange(`A${startRow + 1}:C${startRow + n}`).setValues(resTable);\n\n    const summaryStart = startRow + n + 2;\n    reportSheet.getRange(`A${summaryStart}:C${summaryStart + 2}`).setValues([\n        [\"Max\", max[0], max[1]],\n        [\"Avg\", avg[0], avg[1]],\n        [\"RMS\", rms[0], rms[1]]\n    ]);\n\n    // Apply 12 decimal places formatting to all used cells\n    reportSheet.getUsedRange().setNumberFormatLocal(\"0.000000000000\");\n}\n\n// === Matrix helpers ===\nfunction transpose(matrix: number[][]): number[][] {\n    return matrix[0].map((_, i: number) => matrix.map(row => row[i]));\n}\n\nfunction multiply(a: number[][], b: number[][]): number[][] {\n    const result: number[][] = [];\n    for (let i = 0; i < a.length; i++) {\n        result[i] = [];\n        for (let j = 0; j < b[0].length; j++) {\n            let sum = 0;\n            for (let k = 0; k < b.length; k++) {\n                sum += a[i][k] * b[k][j];\n            }\n            result[i][j] = sum;\n        }\n    }\n    return result;\n}\n\nfunction inverse3x3(m: number[][]): number[][] {\n    const det =\n        m[0][0] * (m[1][1] * m[2][2] - m[1][2] * m[2][1]) -\n        m[0][1] * (m[1][0] * m[2][2] - m[1][2] * m[2][0]) +\n        m[0][2] * (m[1][0] * m[2][1] - m[1][1] * m[2][0]);\n\n    const invDet = 1 / det;\n\n    return [\n        [\n            (m[1][1] * m[2][2] - m[1][2] * m[2][1]) * invDet,\n            (m[0][2] * m[2][1] - m[0][1] * m[2][2]) * invDet,\n            (m[0][1] * m[1][2] - m[0][2] * m[1][1]) * invDet\n        ],\n        [\n            (m[1][2] * m[2][0] - m[1][0] * m[2][2]) * invDet,\n            (m[0][0] * m[2][2] - m[0][2] * m[2][0]) * invDet,\n            (m[0][2] * m[1][0] - m[0][0] * m[1][2]) * invDet\n        ],\n        [\n            (m[1][0] * m[2][1] - m[1][1] * m[2][0]) * invDet,\n            (m[0][1] * m[2][0] - m[0][0] * m[2][1]) * invDet,\n            (m[0][0] * m[1][1] - m[0][1] * m[1][0]) * invDet\n        ]\n    ];\n}\n\n// === Statistics helpers ===\nfunction average(arr: number[]): number {\n    return arr.reduce((a: number, b: number) => a + b, 0) / arr.length;\n}\n\nfunction rmsValue(arr: number[]): number {\n    return Math.sqrt(arr.reduce((sum: number, val: number) => sum + val * val, 0) / arr.length);\n}\n","description":"","noCodeMetadata":"","parameterInfo":"{\"version\":1,\"originalParameterOrder\":[],\"parameterSchema\":{\"type\":\"object\",\"default\":{},\"x-ms-visibility\":\"internal\"},\"returnSchema\":{\"type\":\"object\",\"properties\":{}},\"signature\":{\"comment\":\"\",\"parameters\":[{\"name\":\"workbook\",\"comment\":\"\"}]}}","apiInfo":"{\"variant\":\"synchronous\",\"variantVersion\":2}"}